{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-02522704f2d7183b71da199d697048e5e7f5f01b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/IntegratedCreatorDEX.sol": "project/contracts/IntegratedCreatorDEX.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/math/SafeMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
      },
      "project/contracts/ICreatorMetricsManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title ICreatorMetricsManager\r\n * @dev Interface for CreatorMetricsManager to enable loose coupling\r\n */\r\ninterface ICreatorMetricsManager {\r\n    struct CreatorMetrics {\r\n        uint256 monthlyStreams;\r\n        uint256 followers;\r\n        uint256 monthlyRevenue;\r\n        uint256 engagementScore;\r\n        uint256 lastUpdated;\r\n        uint256 verificationLevel; // 0-4 (unverified to platinum)\r\n    }\r\n    \r\n    // View functions\r\n    function creatorMetrics(address creator) external view returns (\r\n        uint256 monthlyStreams,\r\n        uint256 followers,\r\n        uint256 monthlyRevenue,\r\n        uint256 engagementScore,\r\n        uint256 lastUpdated,\r\n        uint256 verificationLevel\r\n    );\r\n    \r\n    function calculateIntrinsicValue(address creator) external view returns (uint256);\r\n    \r\n    function calculateVerificationLevel(address creator) external view returns (uint256);\r\n    \r\n    function meetsLaunchRequirements(address creator) external view returns (bool);\r\n    \r\n    // Management functions\r\n    function updateCreatorMetrics(\r\n        address creator,\r\n        uint256 monthlyStreams,\r\n        uint256 followers,\r\n        uint256 monthlyRevenue,\r\n        uint256 engagementScore\r\n    ) external;\r\n    \r\n    function addAuthorizedOracle(address oracle) external;\r\n    \r\n    function removeAuthorizedOracle(address oracle) external;\r\n    \r\n    // Events\r\n    event MetricsUpdated(\r\n        address indexed creator,\r\n        uint256 streams,\r\n        uint256 followers,\r\n        uint256 revenue,\r\n        uint256 newIntrinsicValue\r\n    );\r\n}"
      },
      "project/contracts/IntegratedCreatorDEX.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./ICreatorMetricsManager.sol\";\r\n\r\ninterface IBalancedCreatorToken {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function creator() external view returns (address);\r\n    function tradingPaused() external view returns (bool);\r\n}\r\n\r\ninterface ICreatorTokenFactory {\r\n    function getCreatorCoinInfo(address creator) external view returns (\r\n        address coinAddress,\r\n        uint256 intrinsicValue,\r\n        uint256 circulatingSupply,\r\n        uint256 reserveRatio,\r\n        bool hasRevenueBacking\r\n    );\r\n}\r\n\r\ncontract IntegratedCreatorDEX is ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    ICreatorTokenFactory public creatorTokenFactory;\r\n    \r\n    struct LiquidityPool {\r\n        address creatorToken;\r\n        uint256 filReserve;\r\n        uint256 tokenReserve;\r\n        uint256 totalLiquidity;\r\n        uint256 liquidityLockUntil;\r\n        bool isActive;\r\n        mapping(address => uint256) liquidityBalances;\r\n        mapping(address => uint256) liquidityLockTime;\r\n    }\r\n    \r\n    struct TradingMetrics {\r\n        uint256 volume24h;\r\n        uint256 priceChange24h;\r\n        uint256 lastPrice;\r\n        uint256 allTimeHigh;\r\n        uint256 allTimeLow;\r\n        uint256 marketCap;\r\n    }\r\n    \r\n    struct OrderBook {\r\n        // uint256[] buyOrders;   // For limit orders (future feature)\r\n        // uint256[] sellOrders;\r\n        mapping(uint256 => address) orderOwners;\r\n        uint256 u;\r\n    }\r\n    \r\n    mapping(address => LiquidityPool) public pools;\r\n    mapping(address => TradingMetrics) public tradingMetrics;\r\n    mapping(address => OrderBook) public orderBooks;\r\n    \r\n    // Trading parameters\r\n    uint256 public tradingFee = 30; // 0.3%\r\n    uint256 public maxSlippage = 500; // 5%\r\n    uint256 public minLiquidityLock = 30 days;\r\n    \r\n    // Circuit breakers for extreme volatility\r\n    uint256 public maxPriceChangePercent = 5000; // 50% max change\r\n    uint256 public circuitBreakerCooldown = 1 hours;\r\n    \r\n    mapping(address => uint256) public lastCircuitBreaker;\r\n    \r\n    event PoolCreated(address indexed creatorToken, address indexed creator);\r\n    event LiquidityAdded(\r\n        address indexed creatorToken, \r\n        address indexed provider, \r\n        uint256 filAmount, \r\n        uint256 tokenAmount,\r\n        uint256 liquidityMinted\r\n    );\r\n    event LiquidityRemoved(\r\n        address indexed creatorToken,\r\n        address indexed provider,\r\n        uint256 filAmount,\r\n        uint256 tokenAmount,\r\n        uint256 liquidityBurned\r\n    );\r\n    event TokensTraded(\r\n        address indexed creatorToken,\r\n        address indexed trader,\r\n        uint256 filAmount,\r\n        uint256 tokenAmount,\r\n        bool isBuy,\r\n        uint256 price\r\n    );\r\n    event CircuitBreakerTriggered(address indexed creatorToken, uint256 priceChange);\r\n    \r\n    constructor(address _creatorTokenFactory) {\r\n        creatorTokenFactory = ICreatorTokenFactory(_creatorTokenFactory);\r\n    }\r\n    \r\n    // Create liquidity pool for creator token\r\n    function createPool(address creatorToken) external returns (bool) {\r\n        require(pools[creatorToken].creatorToken == address(0), \"Pool exists\");\r\n        require(!IBalancedCreatorToken(creatorToken).tradingPaused(), \"Trading paused\");\r\n        \r\n        // Verify this is a valid creator token\r\n        (address coinAddress, uint256 intrinsicValue,,, bool hasRevenueBacking) = \r\n            creatorTokenFactory.getCreatorCoinInfo(IBalancedCreatorToken(creatorToken).creator());\r\n        require(coinAddress == creatorToken, \"Invalid creator token\");\r\n        require(intrinsicValue > 0, \"No intrinsic value\");\r\n        \r\n        pools[creatorToken].creatorToken = creatorToken;\r\n        pools[creatorToken].isActive = true;\r\n        \r\n        // Initialize trading metrics\r\n        tradingMetrics[creatorToken].lastPrice = intrinsicValue.div(1e18); // Convert to reasonable price\r\n        tradingMetrics[creatorToken].allTimeHigh = tradingMetrics[creatorToken].lastPrice;\r\n        tradingMetrics[creatorToken].allTimeLow = tradingMetrics[creatorToken].lastPrice;\r\n        \r\n        emit PoolCreated(creatorToken, IBalancedCreatorToken(creatorToken).creator());\r\n        return true;\r\n    }\r\n    \r\n    // Add liquidity to pool (creator or fans can provide)\r\n    function addLiquidity(\r\n        address creatorToken, \r\n        uint256 tokenAmount,\r\n        uint256 lockDuration\r\n    ) external payable nonReentrant returns (uint256 liquidityMinted) {\r\n        \r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(msg.value > 0 && tokenAmount > 0, \"Invalid amounts\");\r\n        require(lockDuration >= minLiquidityLock, \"Lock duration too short\");\r\n        \r\n        // Transfer tokens from user\r\n        require(\r\n            IBalancedCreatorToken(creatorToken).transferFrom(msg.sender, address(this), tokenAmount),\r\n            \"Token transfer failed\"\r\n        );\r\n        \r\n        if (pool.totalLiquidity == 0) {\r\n            // First liquidity provider sets initial ratio\r\n            liquidityMinted = msg.value; // Use FIL amount as initial liquidity tokens\r\n            pool.filReserve = msg.value;\r\n            pool.tokenReserve = tokenAmount;\r\n        } else {\r\n            // Maintain existing ratio\r\n            uint256 filRatio = msg.value.mul(pool.totalLiquidity).div(pool.filReserve);\r\n            uint256 tokenRatio = tokenAmount.mul(pool.totalLiquidity).div(pool.tokenReserve);\r\n            \r\n            liquidityMinted = filRatio < tokenRatio ? filRatio : tokenRatio;\r\n            \r\n            // Calculate required amounts to maintain ratio\r\n            uint256 requiredFil = liquidityMinted.mul(pool.filReserve).div(pool.totalLiquidity);\r\n            uint256 requiredTokens = liquidityMinted.mul(pool.tokenReserve).div(pool.totalLiquidity);\r\n            \r\n            // Refund excess\r\n            if (msg.value > requiredFil) {\r\n                payable(msg.sender).transfer(msg.value.sub(requiredFil));\r\n            }\r\n            if (tokenAmount > requiredTokens) {\r\n                IBalancedCreatorToken(creatorToken).transfer(msg.sender, tokenAmount.sub(requiredTokens));\r\n            }\r\n            \r\n            pool.filReserve = pool.filReserve.add(requiredFil);\r\n            pool.tokenReserve = pool.tokenReserve.add(requiredTokens);\r\n        }\r\n        \r\n        pool.totalLiquidity = pool.totalLiquidity.add(liquidityMinted);\r\n        pool.liquidityBalances[msg.sender] = pool.liquidityBalances[msg.sender].add(liquidityMinted);\r\n        pool.liquidityLockTime[msg.sender] = block.timestamp.add(lockDuration);\r\n        \r\n        emit LiquidityAdded(creatorToken, msg.sender, msg.value, tokenAmount, liquidityMinted);\r\n    }\r\n    \r\n    // Remove liquidity (after lock period)\r\n    function removeLiquidity(\r\n        address creatorToken, \r\n        uint256 liquidityAmount\r\n    ) external nonReentrant returns (uint256 filAmount, uint256 tokenAmount) {\r\n        \r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        require(liquidityAmount > 0, \"Invalid amount\");\r\n        require(pool.liquidityBalances[msg.sender] >= liquidityAmount, \"Insufficient liquidity\");\r\n        require(block.timestamp >= pool.liquidityLockTime[msg.sender], \"Liquidity still locked\");\r\n        \r\n        // Calculate amounts to return\r\n        filAmount = liquidityAmount.mul(pool.filReserve).div(pool.totalLiquidity);\r\n        tokenAmount = liquidityAmount.mul(pool.tokenReserve).div(pool.totalLiquidity);\r\n        \r\n        // Update pool state\r\n        pool.liquidityBalances[msg.sender] = pool.liquidityBalances[msg.sender].sub(liquidityAmount);\r\n        pool.totalLiquidity = pool.totalLiquidity.sub(liquidityAmount);\r\n        pool.filReserve = pool.filReserve.sub(filAmount);\r\n        pool.tokenReserve = pool.tokenReserve.sub(tokenAmount);\r\n        \r\n        // Transfer assets back\r\n        payable(msg.sender).transfer(filAmount);\r\n        IBalancedCreatorToken(creatorToken).transfer(msg.sender, tokenAmount);\r\n        \r\n        emit LiquidityRemoved(creatorToken, msg.sender, filAmount, tokenAmount, liquidityAmount);\r\n    }\r\n    \r\n    // Buy creator tokens with FIL\r\n    function buyTokens(\r\n        address creatorToken,\r\n        uint256 minTokensOut\r\n    ) external payable nonReentrant returns (uint256 tokensOut) {\r\n        \r\n        require(msg.value > 0, \"Must send FIL\");\r\n        \r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(!IBalancedCreatorToken(creatorToken).tradingPaused(), \"Trading paused\");\r\n        \r\n        // Check circuit breaker\r\n        require(\r\n            block.timestamp >= lastCircuitBreaker[creatorToken].add(circuitBreakerCooldown),\r\n            \"Circuit breaker active\"\r\n        );\r\n        \r\n        // Calculate output with fee\r\n        uint256 filWithFee = msg.value.mul(uint256(10000).sub(tradingFee)).div(10000);\r\n        tokensOut = filWithFee.mul(pool.tokenReserve).div(pool.filReserve.add(filWithFee));\r\n        \r\n        require(tokensOut >= minTokensOut, \"Insufficient output amount\");\r\n        require(tokensOut < pool.tokenReserve, \"Insufficient liquidity\");\r\n        \r\n        // Calculate price change and check circuit breaker (disabled for testing)\r\n        uint256 newPrice = pool.filReserve.add(msg.value).mul(1e18).div(pool.tokenReserve.sub(tokensOut));\r\n        \r\n        // Circuit breaker temporarily disabled for testing\r\n        // if (tradingMetrics[creatorToken].lastPrice > 0) {\r\n        //     uint256 priceChange = newPrice > tradingMetrics[creatorToken].lastPrice ?\r\n        //         newPrice.sub(tradingMetrics[creatorToken].lastPrice).mul(10000).div(tradingMetrics[creatorToken].lastPrice) :\r\n        //         tradingMetrics[creatorToken].lastPrice.sub(newPrice).mul(10000).div(tradingMetrics[creatorToken].lastPrice);\r\n        //     \r\n        //     if (priceChange > maxPriceChangePercent) {\r\n        //         lastCircuitBreaker[creatorToken] = block.timestamp;\r\n        //         emit CircuitBreakerTriggered(creatorToken, priceChange);\r\n        //         revert(\"Price change too large - circuit breaker triggered\");\r\n        //     }\r\n        // }\r\n        \r\n        // Update pool reserves\r\n        pool.filReserve = pool.filReserve.add(msg.value);\r\n        pool.tokenReserve = pool.tokenReserve.sub(tokensOut);\r\n        \r\n        // Update trading metrics\r\n        _updateTradingMetrics(creatorToken, newPrice, msg.value);\r\n        \r\n        // Transfer tokens (this will trigger BalancedCreatorToken anti-manipulation checks)\r\n        require(\r\n            IBalancedCreatorToken(creatorToken).transfer(msg.sender, tokensOut),\r\n            \"Token transfer failed\"\r\n        );\r\n        \r\n        emit TokensTraded(creatorToken, msg.sender, msg.value, tokensOut, true, newPrice);\r\n    }\r\n    \r\n    // Sell creator tokens for FIL\r\n    function sellTokens(\r\n        address creatorToken,\r\n        uint256 tokenAmount,\r\n        uint256 minFilOut\r\n    ) external nonReentrant returns (uint256 filOut) {\r\n        \r\n        require(tokenAmount > 0, \"Must send tokens\");\r\n        \r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        require(pool.isActive, \"Pool not active\");\r\n        require(!IBalancedCreatorToken(creatorToken).tradingPaused(), \"Trading paused\");\r\n        \r\n        // Transfer tokens from user (triggers anti-manipulation checks)\r\n        require(\r\n            IBalancedCreatorToken(creatorToken).transferFrom(msg.sender, address(this), tokenAmount),\r\n            \"Token transfer failed\"\r\n        );\r\n        \r\n        // Calculate FIL output with fee\r\n        uint256 tokenAmountWithFee = tokenAmount.mul(uint256(10000).sub(tradingFee)).div(10000);\r\n        filOut = tokenAmountWithFee.mul(pool.filReserve).div(pool.tokenReserve.add(tokenAmountWithFee));\r\n        \r\n        require(filOut >= minFilOut, \"Insufficient output amount\");\r\n        require(filOut < pool.filReserve, \"Insufficient liquidity\");\r\n        \r\n        // Update pool reserves\r\n        pool.tokenReserve = pool.tokenReserve.add(tokenAmount);\r\n        pool.filReserve = pool.filReserve.sub(filOut);\r\n        \r\n        // Calculate new price\r\n        uint256 newPrice = pool.filReserve.mul(1e18).div(pool.tokenReserve);\r\n        \r\n        // Update trading metrics\r\n        _updateTradingMetrics(creatorToken, newPrice, filOut);\r\n        \r\n        // Transfer FIL to user\r\n        payable(msg.sender).transfer(filOut);\r\n        \r\n        emit TokensTraded(creatorToken, msg.sender, filOut, tokenAmount, false, newPrice);\r\n    }\r\n    \r\n    // Internal function to update trading metrics\r\n    function _updateTradingMetrics(address creatorToken, uint256 newPrice, uint256 volume) internal {\r\n        TradingMetrics storage metrics = tradingMetrics[creatorToken];\r\n        \r\n        // Update 24h volume (simplified - would need time-based tracking in production)\r\n        metrics.volume24h = metrics.volume24h.add(volume);\r\n        \r\n        // Update price change\r\n        if (metrics.lastPrice > 0) {\r\n            metrics.priceChange24h = newPrice > metrics.lastPrice ?\r\n                newPrice.sub(metrics.lastPrice).mul(10000).div(metrics.lastPrice) :\r\n                metrics.lastPrice.sub(newPrice).mul(10000).div(metrics.lastPrice);\r\n        }\r\n        \r\n        metrics.lastPrice = newPrice;\r\n        \r\n        // Update all-time high/low\r\n        if (newPrice > metrics.allTimeHigh) {\r\n            metrics.allTimeHigh = newPrice;\r\n        }\r\n        if (newPrice < metrics.allTimeLow) {\r\n            metrics.allTimeLow = newPrice;\r\n        }\r\n        \r\n        // Update market cap\r\n        uint256 totalSupply = IBalancedCreatorToken(creatorToken).totalSupply();\r\n        metrics.marketCap = newPrice.mul(totalSupply).div(1e18);\r\n    }\r\n    \r\n    // Get expected output for buying tokens\r\n    function getTokensOut(address creatorToken, uint256 filIn) external view returns (uint256) {\r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        if (pool.filReserve == 0 || pool.tokenReserve == 0) return 0;\r\n        \r\n        uint256 filWithFee = filIn.mul(uint256(10000).sub(tradingFee)).div(10000);\r\n        return filWithFee.mul(pool.tokenReserve).div(pool.filReserve.add(filWithFee));\r\n    }\r\n    \r\n    // Get expected output for selling tokens\r\n    function getFilOut(address creatorToken, uint256 tokenIn) external view returns (uint256) {\r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        if (pool.filReserve == 0 || pool.tokenReserve == 0) return 0;\r\n        \r\n        uint256 tokenWithFee = tokenIn.mul(uint256(10000).sub(tradingFee)).div(10000);\r\n        return tokenWithFee.mul(pool.filReserve).div(pool.tokenReserve.add(tokenWithFee));\r\n    }\r\n    \r\n    // Get current token price\r\n    function getCurrentPrice(address creatorToken) external view returns (uint256) {\r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        if (pool.tokenReserve == 0) return 0;\r\n        return pool.filReserve.mul(1e18).div(pool.tokenReserve);\r\n    }\r\n    \r\n    // Get pool info\r\n    function getPoolInfo(address creatorToken) external view returns (\r\n        uint256 filReserve,\r\n        uint256 tokenReserve,\r\n        uint256 totalLiquidity,\r\n        uint256 currentPrice,\r\n        bool isActive\r\n    ) {\r\n        LiquidityPool storage pool = pools[creatorToken];\r\n        currentPrice = pool.tokenReserve > 0 ? pool.filReserve.mul(1e18).div(pool.tokenReserve) : 0;\r\n        return (\r\n            pool.filReserve,\r\n            pool.tokenReserve,\r\n            pool.totalLiquidity,\r\n            currentPrice,\r\n            pool.isActive\r\n        );\r\n    }\r\n    \r\n    // Admin functions\r\n    function setTradingFee(uint256 _fee) external onlyOwner {\r\n        require(_fee <= 1000, \"Fee too high\"); // Max 10%\r\n        tradingFee = _fee;\r\n    }\r\n    \r\n    function pausePool(address creatorToken) external onlyOwner {\r\n        pools[creatorToken].isActive = false;\r\n    }\r\n    \r\n    function unpausePool(address creatorToken) external onlyOwner {\r\n        pools[creatorToken].isActive = true;\r\n    }\r\n}"
      }
    }
  }
}